<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Territorial ‚Äî Multiplayer Ready (Fixed)</title>
<style>
html,body{margin:0;padding:0;overflow:hidden;background:#0d1117;font-family:Tahoma,Arial,sans-serif}
canvas{display:block;touch-action:none}
/* Lobby */
#lobby{position:fixed;inset:0;z-index:2000;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,#0d1117,#111827,#1a2333);animation:bgMove 8s infinite alternate}
@keyframes bgMove{0%{filter:brightness(1)}100%{filter:brightness(1.12)}}
.card{background:rgba(6,10,18,0.7);backdrop-filter:blur(8px);padding:24px;border-radius:14px;width:360px;box-shadow:0 12px 40px rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.04);color:#e6eef8}
.card h1{margin:0 0 12px;font-size:20px;text-align:center}
#telegramTag{font-size:20px;font-weight:700;color:#ff3333;text-align:center;margin-bottom:10px;text-shadow:0 0 8px rgba(255,0,0,0.12),0 0 18px rgba(255,0,0,0.06)}
label{display:block;color:#aeb9c8;margin-top:10px}
select,input[type=range]{width:100%;margin:8px 0;padding:10px;border-radius:10px;border:none;background:#101521;color:#fff}
button{padding:12px;border-radius:10px;border:none;cursor:pointer;font-weight:700}
.green{background:#16a34a;color:white}
#ratioBar{position:fixed;left:50%;transform:translateX(-50%);bottom:12px;background:rgba(255,255,255,0.92);padding:10px 12px;border-radius:14px;display:flex;align-items:center;gap:12px;z-index:1800}
#ratioBar input{width:160px}
#legend{position:fixed;left:12px;top:12px;z-index:1800;color:white;display:flex;flex-direction:column;gap:6px}
.legend-item{display:flex;align-items:center;gap:8px;background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:8px}
#dbg{position:fixed;right:8px;bottom:8px;z-index:2200;background:rgba(0,0,0,0.7);color:#fff;padding:8px;border-radius:8px;font-size:12px;display:none;max-width:40vw}
#mainMenuBtn{position:fixed;right:12px;top:12px;z-index:2100;background:#2563eb;color:white;padding:8px 12px;border-radius:10px;box-shadow:0 8px 20px rgba(0,0,0,0.3);cursor:pointer}
#victoryOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:3000}
#victoryCard{background:linear-gradient(180deg,rgba(255,255,255,0.06),rgba(255,255,255,0.03));backdrop-filter:blur(8px);padding:28px;border-radius:16px;text-align:center;color:white;box-shadow:0 30px 80px rgba(0,0,0,0.6)}
#victoryCard h1{margin:8px 0 6px 0;font-size:32px}
#victoryCard .crown{font-size:46px;filter:drop-shadow(0 8px 20px rgba(255,215,0,0.3))}
#victoryCard button{margin-top:12px;padding:10px 16px;border-radius:10px;border:none;cursor:pointer}
#consoleBtn{position:fixed;left:12px;top:12px;z-index:4000;background:#111;color:#fff;padding:6px 10px;border-radius:10px;font-weight:700;cursor:pointer}
#inGameConsole{position:fixed;right:12px;top:12px;width:360px;height:280px;background:#000;border-radius:8px;z-index:4001;color:#0f0;padding:12px;display:none;overflow:auto;font-family:monospace;font-size:14px}
</style>
</head>
<body>

<!-- Two canvases: main + line layer -->
<canvas id="game"></canvas>
<canvas id="lineLayer" style="position:fixed;inset:0;pointer-events:none;z-index:1700"></canvas>

<!-- Ratio bar -->
<div id="ratioBar" aria-hidden="false">
  <span style="font-weight:700">ÿßŸÑŸÇŸàÿßÿ™:</span>
  <input id="ratioSlider" type="range" min="10" max="100" value="50">
  <span id="ratioValue">50%</span>
</div>

<!-- Main Menu Button -->
<div id="mainMenuBtn" role="button">‚üµ ÿ±ÿ¨Ÿàÿπ</div>

<!-- Lobby -->
<div id="lobby" role="dialog" aria-label="Lobby">
  <div class="card">
    <h1>ŸÑŸàÿ®Ÿä ÿßŸÑŸÑÿπÿ®ÿ©</h1>
    <div id="telegramTag">@Z_S_T_O</div>

    <label>ÿπÿØÿØ ÿßŸÑŸÑÿßÿπÿ®ŸäŸÜ</label>
    <select id="playerCount">
      <option value="2">2</option>
      <option value="3">3</option>
      <option value="4" selected>4</option>
    </select>

    <label>ŸÖÿπÿØŸÑ ÿßŸÑÿ•ŸÜÿ™ÿßÿ¨ (ŸÖŸÑŸÑŸä ÿ´ÿßŸÜŸäÿ©)</label>
    <input id="prodRate" type="range" min="300" max="2000" value="900">

    <div style="margin-top:12px">
      <button id="startBtn" class="green" style="width:100%">ÿßÿ®ÿØÿ£</button>

    <style>
    /* Simple styling for lobby modal and button */
    #onlineBtn {
      display:block;
      margin:16px auto;
      padding:14px 20px;
      background:#0b8f3b;
      color:#fff;
      border-radius:12px;
      font-size:18px;
      border:none;
      cursor:pointer;
      max-width:360px;
      width:90%;
      text-align:center;
    }
    #lobbyModal {
      display:none;
      position:fixed;
      z-index:9999;
      left:0; top:0; right:0; bottom:0;
      background:rgba(0,0,0,0.6);
      align-items:center;
      justify-content:center;
      padding:20px;
    }
    #lobbyBox {
      background:#111; color:#fff; border-radius:12px; padding:18px; max-width:420px; width:100%;
      box-shadow:0 10px 30px rgba(0,0,0,0.7);
    }
    #lobbyBox input, #lobbyBox button {
      width:100%; padding:10px; margin:8px 0; border-radius:8px; border:1px solid #333; background:#0f0f10; color:#fff;
    }
    #playersList { max-height:160px; overflow:auto; margin:8px 0; padding:6px; background:#071018; border-radius:6px; }
    .playerItem { padding:6px; border-bottom:1px solid rgba(255,255,255,0.03); display:flex; justify-content:space-between; align-items:center;}
    .hostBadge { background:#ffd633; color:#000; padding:4px 8px; border-radius:6px; font-weight:700; font-size:12px; }
    #startGameBtn { background:#1976d2; color:#fff; border:none; }
    #leaveBtn { background:#b71c1c; color:#fff; border:none; }
    </style>

    <button id="onlineBtn">ÿßŸÑŸÑÿπÿ® ÿ£ŸàŸÜŸÑÿßŸäŸÜ</button>

    <div id="lobbyModal" role="dialog" aria-hidden="true">
      <div id="lobbyBox">
        <h2 style="text-align:center;margin:0 0 8px 0;">ŸÑŸàÿ®Ÿä ÿßŸÑŸÑÿπÿ®ÿ©</h2>
        <input id="nicknameInput" placeholder="ÿßŸÑÿßÿ≥ŸÖ (ŸÖÿ´ÿßŸÑ: Ali)" />
        <div style="display:flex;gap:8px;">
          <button id="createRoomBtn" style="flex:1;background:#2e7d32;">ÿßŸÜÿ¥ÿßÿ° ÿ∫ÿ±ŸÅÿ©</button>
          <button id="joinRoomBtn" style="flex:1;background:#455a64;">ÿßŸÜÿ∂ŸÖ ŸÑÿ∫ÿ±ŸÅÿ©</button>
        </div>
        <input id="roomIdInput" placeholder="ŸÖÿπÿ±ŸÅ ÿßŸÑÿ∫ÿ±ŸÅÿ© (Room ID)" />
        <div id="playersList" aria-live="polite"></div>
        <div style="display:flex;gap:8px;margin-top:8px;">
          <button id="startGameBtn" style="flex:1;" disabled>ÿ®ÿØÿ° ÿßŸÑŸÑÿπÿ®ÿ© (ŸÅŸÇÿ∑ ÿßŸÑŸáŸàÿ≥ÿ™)</button>
          <button id="leaveBtn" style="flex:1;display:none;">ÿßŸÑÿÆÿ±Ÿàÿ¨</button>
        </div>
        <div style="margin-top:8px;font-size:12px;color:#ccc;">ŸÇŸàÿßÿπÿØ: ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ 4 ŸÑÿßÿπÿ®ŸäŸÜ. ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ÿØŸÜŸâ ŸÑÿ®ÿØÿ° ÿßŸÑŸÑÿπÿ®ÿ©: 2</div>
      </div>
    </div>

    </div>
  </div>
</div>

<div id="legend" aria-hidden="true"></div>
<div id="dbg" role="status"></div>

<!-- In-game console + button -->
<button id="consoleBtn">Console</button>
<div id="inGameConsole" aria-live="polite"></div>

<!-- Victory overlay -->
<div id="victoryOverlay"><div id="victoryCard"><div class="crown">üëë</div><h1 id="victoryText"></h1><div id="victorName" style="font-size:20px;margin-top:6px"></div><button id="victoryToLobby" class="green">ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑŸëŸàÿ®Ÿä</button></div></div>

<script>
// Important: declare grid at top-level (var) to avoid TDZ errors
var grid = [];

function debugLog(msg, color="#0f0"){ // prints to in-game console
  try{
    const c = document.getElementById('inGameConsole');
    if(!c) return;
    const line = document.createElement('div');
    line.style.color = color;
    line.textContent = msg;
    c.appendChild(line);
    c.scrollTop = c.scrollHeight;
  }catch(e){}
}
document.addEventListener('DOMContentLoaded', ()=>{
  const consoleBtn = document.getElementById('consoleBtn');
  const inGameConsole = document.getElementById('inGameConsole');
  consoleBtn.addEventListener('click', ()=>{
    if(inGameConsole.style.display === 'none' || inGameConsole.style.display===''){
      inGameConsole.style.display = 'block';
      debugLog('Console opened', '#0f0');
    } else {
      inGameConsole.style.display = 'none';
    }
  });
});
</script>

<script>
document.addEventListener('DOMContentLoaded', ()=>{
  'use strict';

  // constants + elements
  const HEX = 34;
  const DEFEND_RADIUS = HEX * 3.2; // for danger indicator
  const gameCanvas = document.getElementById('game');
  const lineCanvas = document.getElementById('lineLayer');
  const dbg = document.getElementById('dbg');
  const ratioSlider = document.getElementById('ratioSlider');
  const ratioValue = document.getElementById('ratioValue');
  const startBtn = document.getElementById('startBtn');
  const playerCount = document.getElementById('playerCount');
  const prodRate = document.getElementById('prodRate');
  const legendEl = document.getElementById('legend');
  const mainMenuBtn = document.getElementById('mainMenuBtn');
  const victoryOverlay = document.getElementById('victoryOverlay');
  const victoryText = document.getElementById('victoryText');
  const victorName = document.getElementById('victorName');
  const victoryToLobby = document.getElementById('victoryToLobby');

  if(!gameCanvas || !lineCanvas){ dbg.style.display='block'; dbg.textContent='ÿÆÿ∑ÿ£: ÿπŸÜÿßÿµÿ± ÿßŸÑÿ±ÿ≥ŸÖ ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©'; return; }
  const ctx = gameCanvas.getContext('2d');
  const lctx = lineCanvas.getContext('2d');
  if(!ctx || !lctx){ dbg.style.display='block'; dbg.textContent='ÿÆÿ∑ÿ£: ÿ™ÿπÿ∞ÿ± ÿ•ŸÜÿ¥ÿßÿ° ÿ≥ŸäÿßŸÇ 2D'; return; }

  // sizes
  let W = 0, H = 0;
  let needRender = true; // declared early
  function resize(){ W = gameCanvas.width = window.innerWidth || 300; H = gameCanvas.height = window.innerHeight || 200; lineCanvas.width = W; lineCanvas.height = H; needRender = true; }
  window.addEventListener('resize', resize);
  resize();

  // --------------------
  // GAME STATE (declare & init inside to avoid surprises)
  // --------------------
  var players = [];
  var cam = { x:0, y:0, scale:1 };
  var selected = null;
  var animations = [];
  var effects = []; // visual effects (explosions, pulses)
  var prodTimer = null, botTimer = null;
  var dragging = false, lastX = 0, lastY = 0;

  // multiplayer local mapping
  var multiplayerMode = false;
  var localPlayerIndex = 0; // in multiplayer, index in players[] that is this client
  var currentRoomPlayersList = []; // snapshot of DB players order
  var roomHostId = null;
  var currentRoom = null;

  // Audio
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const audioCtx = AudioCtx ? new AudioCtx() : null;
  function playTone(freq, duration=0.3, type='sine'){ if(!audioCtx) return; const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type = type; o.frequency.value = freq; o.connect(g); g.connect(audioCtx.destination); const now = audioCtx.currentTime; g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(0.12, now + 0.01); o.start(now); g.gain.exponentialRampToValueAtTime(0.0001, now + duration); o.stop(now + duration + 0.02); }
  function playVictorySound(){ playTone(880,0.5,'sine'); setTimeout(()=>playTone(660,0.35,'sine'),120); }
  function playEliminatedSound(){ playTone(180,0.22,'sawtooth'); }
  function playCaptureSound(){ playTone(520,0.18,'triangle'); }
  function playCapitalCapture(){ playTone(760,0.45,'sine'); setTimeout(()=>playTone(520,0.3,'triangle'),160); }

  // safe render wrapper
  function renderSafe(){ try{ updateAnimations(16); render(); }catch(e){ console.error(e); debugLog('renderSafe error: '+String(e),'#f55'); dbg.style.display='block'; dbg.textContent = String(e); } }

  // --------------------
  // GRID & HELPERS
  // --------------------
  function HEXR(){ return HEX; }
  function buildGrid(){
    // ensure grid variable exists (declared at top)
    grid.length = 0; // reuse array reference
    const cols = Math.max(8, Math.floor(W / (HEXR() * 1.6)));
    const rows = Math.max(6, Math.floor(H / (HEXR() * 1.25)));
    const startX = -cols * HEX * 0.85;
    const startY = -rows * HEX * 0.95;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const x = startX + c * HEX * 1.7 + (r % 2 ? HEX * 0.85 : 0);
        const y = startY + r * HEX * 1.45;
        grid.push({ x, y, owner:null, troops:0, neighbors:[] });
      }
    }
    for(let i=0;i<grid.length;i++){
      const a = grid[i];
      for(let j=0;j<grid.length;j++){
        if(i===j) continue;
        const b = grid[j];
        if(Math.hypot(a.x - b.x, a.y - b.y) < HEX * 1.75) a.neighbors.push(j);
      }
    }
    needRender = true;
  }

  function worldToScreen(x,y){ return { x:(x + cam.x) * cam.scale + W/2, y:(y + cam.y) * cam.scale + H/2 }; }
  function screenToWorld(sx,sy){ return { x:(sx - W/2) / cam.scale - cam.x, y:(sy - H/2) / cam.scale - cam.y }; }
  function drawHex(cx,cy,r){ ctx.beginPath(); for(let i=0;i<6;i++){ const a=Math.PI/3*i + Math.PI/6; const x=cx+Math.cos(a)*r; const y=cy+Math.sin(a)*r; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); } ctx.closePath(); }
  function cellAt(wx,wy){ if(!grid || grid.length===0) return null; let best=null, bd=HEX*1.05; for(let i=0;i<grid.length;i++){ const d=Math.hypot(grid[i].x-wx, grid[i].y-wy); if(d<bd){ bd=d; best=i; } } return best; }
  function isNeighbor(a,b){ if(!grid||!grid[a]||!grid[b]) return false; return Math.hypot(grid[a].x-grid[b].x, grid[a].y-grid[b].y) < HEX * 1.8; }

  // --------------------
  // PLAYERS / CAPITALS
  // --------------------
  function setupPlayers(n){
    players = [];
    for(let i=0;i<n;i++){
      const defaultColors=['#3399ff','#ff5555','#ffe047','#8a60ff','#00c48c'];
      players.push({ id:i, color:defaultColors[i%defaultColors.length], name:'P'+(i+1), capital:null, alive:true, dbId:null });
    }
    updateLegend();
    needRender = true;
  }

  // helper to pick unique colors from pool
  function pickUniqueColors(existing){
    const pool = ['#e53935','#8e24aa','#3949ab','#00897b','#f4511e','#fb8c00','#43a047','#1e88e5','#7b1fa2','#d32f2f'];
    const used = new Set(existing || []);
    const out = [];
    for(let i=0;i<pool.length && out.length<4;i++){
      if(!used.has(pool[i])) out.push(pool[i]);
    }
    // if still not enough, fill with random
    while(out.length < 4){
      const c = pool[Math.floor(Math.random()*pool.length)];
      if(!out.includes(c)) out.push(c);
    }
    return out;
  }

  // seed capitals for multiplayer: put each player's capital at map corners (one hex each)
  function seedCapitalsMultiplayer(dbPlayersArr){
    if(!grid || grid.length===0) buildGrid();
    grid.forEach(c=>{ c.owner=null; c.troops=0; });
    const xs = grid.map(c=>c.x), ys = grid.map(c=>c.y);
    const cxMin = Math.min(...xs), cxMax = Math.max(...xs);
    const cyMin = Math.min(...ys), cyMax = Math.max(...ys);
    const corners = [[cxMin,cyMin],[cxMax,cyMin],[cxMin,cyMax],[cxMax,cyMax]];
    const n = dbPlayersArr.length;
    for(let p=0;p<n;p++){
      const pt = corners[p % corners.length];
      let bestIdx=0, bestD=Infinity;
      for(let i=0;i<grid.length;i++){
        const d=Math.hypot(grid[i].x-pt[0], grid[i].y-pt[1]);
        if(d<bestD){ bestD=d; bestIdx=i; }
      }
      grid[bestIdx].owner = p;
      grid[bestIdx].troops = 40;
      players[p].capital = bestIdx;
      players[p].dbId = dbPlayersArr[p].id;
      players[p].name = dbPlayersArr[p].name || players[p].name;
      players[p].color = dbPlayersArr[p].color || players[p].color;
    }
    needRender = true;
  }

  // fallback seed for offline / singleplayer (keeps previous behavior)
  function seedCapitals(){
    if(!grid || grid.length===0) buildGrid();
    grid.forEach(c=>{ c.owner=null; c.troops=0; });
    const xs = grid.map(c=>c.x), ys = grid.map(c=>c.y); if(xs.length===0||ys.length===0) return;
    const cxMin = Math.min(...xs), cxMax = Math.max(...xs);
    const cyMin = Math.min(...ys), cyMax = Math.max(...ys);
    const corners = [[cxMin,cyMin],[cxMax,cyMin],[cxMin,cyMax],[cxMax,cyMax]];
    const n = players.length;
    for(let p=0;p<n;p++){
      const pt = corners[p % corners.length];
      let bestIdx=0, bestD=Infinity;
      for(let i=0;i<grid.length;i++){
        const d=Math.hypot(grid[i].x-pt[0], grid[i].y-pt[1]);
        if(d<bestD){ bestD=d; bestIdx=i; }
      }
      grid[bestIdx].owner = players[p].id;
      grid[bestIdx].troops = 40;
      players[p].capital = bestIdx;
    }
    for(let i=0;i<grid.length;i++){ if(grid[i].owner==null && Math.random()<0.03){ grid[i].owner = Math.floor(Math.random()*players.length); grid[i].troops = 3 + Math.floor(Math.random()*4); } }
    needRender = true;
  }

  // --------------------
  // PRODUCTION
  // --------------------
  function startProduction(ms){ if(prodTimer) clearInterval(prodTimer); prodTimer = setInterval(()=>{ if(grid && grid.length) grid.forEach(c=>{ if(c.owner != null) c.troops++; }); }, Math.max(50, parseInt(ms,10) || 900)); }

  // --------------------
  // ANIMATIONS
  // --------------------
  function animateMove(fromIdx,toIdx,color){ if(!grid||!grid[fromIdx]||!grid[toIdx]) return; animations.push({ fromIdx,toIdx,color,t:0 }); needRender = true; }
  function updateAnimations(delta){ lctx.clearRect(0,0,W,H); if(!grid||grid.length===0) return; const remaining=[]; for(const a of animations){ a.t += delta*0.004; if(a.t>=1) continue; const A = worldToScreen(grid[a.fromIdx].x, grid[a.fromIdx].y); const B = worldToScreen(grid[a.toIdx].x, grid[a.toIdx].y); const x = A.x + (B.x - A.x) * a.t; const y = A.y + (B.y - A.y) * a.t; lctx.beginPath(); lctx.fillStyle = a.color; lctx.arc(x,y,6*Math.max(0.6,cam.scale),0,Math.PI*2); lctx.fill(); remaining.push(a); } animations = remaining; if(animations.length>0) needRender = true; }

  // --------------------
  // MOVE & ELIMINATION
  // --------------------
  function captureEffect(cellIdx){
    const cell = grid[cellIdx]; if(!cell) return;
    const s = worldToScreen(cell.x, cell.y);
    effects.push({ type:'pulse', x:s.x, y:s.y, r:0, t:0, max: Math.max(W,H)*0.12 });
    playCapitalCapture();
    needRender = true;
  }

  function updateEffects(dt){
    lctx.clearRect(0,0,W,H);
    const keep = [];
    for(const e of effects){
      e.t += dt;
      if(e.type==='pulse'){
        e.r = e.t * 0.4 * (1 + cam.scale);
        const alpha = Math.max(0, 0.8 - e.t*0.008);
        lctx.beginPath(); lctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
        lctx.strokeStyle = 'rgba(255,215,80,'+alpha+')';
        lctx.lineWidth = Math.max(2, 6 * cam.scale);
        lctx.stroke();
        if(e.t < 80){ lctx.fillStyle = 'rgba(255,240,200,' + (0.12 + (80 - e.t)/800) + ')'; lctx.beginPath(); lctx.arc(e.x, e.y, Math.min(e.r, e.max*0.25), 0, Math.PI*2); lctx.fill(); }
        if(e.t < 220) keep.push(e);
      }
    }
    effects.length = 0; Array.prototype.push.apply(effects, keep);
    if(keep.length>0) needRender = true;
  }

  // moveTroops core (no broadcast)
  function moveTroopsInternal(fromIdx,toIdx,ratio){
    if(!grid||!grid[fromIdx]||!grid[toIdx]) return;
    const f = grid[fromIdx], t = grid[toIdx];
    const send = Math.floor(f.troops * ratio);
    if(send <= 0) return;
    f.troops = Math.max(0, f.troops - send);
    animateMove(fromIdx,toIdx, players[f.owner] ? players[f.owner].color : '#fff');
    if(t.owner === f.owner){
      t.troops += send;
    } else {
      if(send > t.troops){
        const defeatedOwner = t.owner;
        t.owner = f.owner;
        t.troops = send - t.troops;
        playCaptureSound();
        if(defeatedOwner != null && players[defeatedOwner] && players[defeatedOwner].capital === toIdx){
          if(players[defeatedOwner]) players[defeatedOwner].alive = false;
          for(const c of grid){ if(c.owner === defeatedOwner){ c.owner = null; c.troops = 0; } }
          playEliminatedSound();
          captureEffect(toIdx);
          checkVictory();
        }
      } else {
        t.troops = Math.max(0, t.troops - send);
      }
    }
    needRender = true;
  }

  // high-level moveTroops that optionally broadcasts to Firebase when in multiplayer
  function moveTroops(fromIdx,toIdx,ratio, broadcast=true){
    moveTroopsInternal(fromIdx,toIdx,ratio);
    if(multiplayerMode && broadcast && window.multiplayer && typeof window.multiplayer.sendAction === 'function'){
      const action = { type:'move', from: fromIdx, to: toIdx, ratio: ratio, ts: Date.now() };
      window.multiplayer.sendAction(action).catch(e=>{ console.error('sendAction error',e); debugLog('sendAction error: '+e,'#f55'); });
    }
  }

  // --------------------
  // BOT (defend capital priority) - disabled in multiplayer
  // --------------------
  function botTick(){ if(multiplayerMode) return; if(!grid||grid.length===0) return; for(let p=1;p<players.length;p++){ const bot = players[p]; if(!bot || !bot.alive) continue; const capIdx = bot.capital; if(typeof capIdx === 'number' && capIdx != null){ const cap = grid[capIdx]; if(cap){ const defendRadius = HEX * 3.2; let threat = null; let threatDist = Infinity; for(let i=0;i<grid.length;i++){ const cell = grid[i]; if(cell.owner != null && cell.owner !== p){ const d = Math.hypot(cell.x - cap.x, cell.y - cap.y); if(d < defendRadius && d < threatDist){ threatDist = d; threat = i; } } } if(threat != null){ const friendlyCells = grid.map((c,idx)=> c.owner===p && c.troops>6 ? idx : null).filter(i=>i!==null); if(friendlyCells.length>0){ friendlyCells.sort((a,b)=> Math.hypot(grid[a].x-cap.x,grid[a].y-cap.y)-Math.hypot(grid[b].x-cap.x,grid[b].y-cap.y)); const origin = friendlyCells[0]; moveTroops(origin, threat, 0.75); continue; } } } } const ownedIdx = grid.map((c,i)=>c.owner===p?i:null).filter(i=>i!==null); if(ownedIdx.length===0) continue; const originIdx = ownedIdx[Math.floor(Math.random()*ownedIdx.length)]; const origin = grid[originIdx]; if(!origin||origin.troops<5) continue; const neighIdx = origin.neighbors.slice(); if(neighIdx.length===0) continue; let weakestIdx = neighIdx[0]; for(const ni of neighIdx) if(grid[ni].troops < grid[weakestIdx].troops) weakestIdx = ni; moveTroops(originIdx, weakestIdx, 0.5); } }

  // --------------------
  // RENDER
  // --------------------
  function drawCapitalMarker(cellIdx){ if(!grid[cellIdx]) return; const c = grid[cellIdx]; const s = worldToScreen(c.x, c.y); ctx.beginPath(); ctx.lineWidth = Math.max(2, 3 * cam.scale); ctx.strokeStyle = 'rgba(255,215,0,0.95)'; ctx.arc(s.x, s.y, HEX * cam.scale + 6 * cam.scale, 0, Math.PI*2); ctx.stroke(); ctx.fillStyle = 'rgba(255,215,0,0.95)'; ctx.font = (18 * Math.max(0.7, cam.scale)) + 'px Tahoma'; ctx.textAlign = 'center'; ctx.fillText('‚òÖ', s.x, s.y - (HEX * cam.scale + 4 * cam.scale)); }

  function render(){ if(!ctx) return; if(!needRender && animations.length===0 && effects.length===0) return; // only render when needed
    ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,W,H); ctx.fillStyle = '#0d1117'; ctx.fillRect(0,0,W,H); if(!grid||grid.length===0) return; for(let i=0;i<grid.length;i++){ const c = grid[i]; const s = worldToScreen(c.x, c.y); drawHex(s.x, s.y, HEX * cam.scale); ctx.fillStyle = c.owner == null ? '#ffffff' : players[c.owner] ? players[c.owner].color : '#fff'; ctx.fill(); if(i === selected){ ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 3; ctx.stroke(); } ctx.fillStyle = '#000'; ctx.textAlign = 'center'; ctx.font = (14 * Math.max(0.7, cam.scale)) + 'px Tahoma'; ctx.fillText(c.troops, s.x, s.y + (5 * cam.scale)); }
    // draw capitals last
    for(const p of players){ if(p && p.capital != null && p.alive){ drawCapitalMarker(p.capital); } }

    // danger indicator: draw small blinking red triangle above capitals when enemy close
    const now = performance.now();
    for(const p of players){ if(!p || p.capital==null || !p.alive) continue; const capIdx = p.capital; const cap = grid[capIdx]; if(!cap) continue; let danger=false; for(let i=0;i<grid.length;i++){ const cell = grid[i]; if(cell.owner != null && cell.owner !== p.id){ const d = Math.hypot(cell.x - cap.x, cell.y - cap.y); if(d < DEFEND_RADIUS){ danger=true; break; } } }
      if(danger){ const s = worldToScreen(cap.x, cap.y); const blink = 0.5 + 0.5 * Math.sin(now * 0.015); ctx.save(); ctx.translate(s.x, s.y - (HEX * cam.scale + 18 * cam.scale)); ctx.scale(cam.scale, cam.scale); ctx.beginPath(); ctx.moveTo(0, -8); ctx.lineTo(7, 8); ctx.lineTo(-7, 8); ctx.closePath(); ctx.fillStyle = 'rgba(255,80,80,'+blink+')'; ctx.fill(); ctx.restore(); }
    }

    needRender = false; // reset flag after rendering
  }

  function updateLegend(){ if(!legendEl) return; legendEl.innerHTML = ''; for(const p of players){ const div = document.createElement('div'); div.className = 'legend-item'; div.innerHTML = `<div style="width:14px;height:10px;background:${p.color};border-radius:4px"></div><div style="font-size:13px">${p.name}</div>`; legendEl.appendChild(div); } }

  // --------------------
  // EFFECTS UPDATE (called from main loop)
  // --------------------
  function updateEffectsAndAnimations(dt){ updateAnimations(dt); updateEffects(dt); }

  // --------------------
  // VICTORY & LOBBY
  // --------------------
  function checkVictory(){ const alive = players.filter(p=>p && p.alive); if(alive.length===1){ const winner = alive[0]; if(prodTimer) clearInterval(prodTimer); if(botTimer) clearInterval(botTimer); victoryText.textContent = 'ÿßŸÑŸÅÿßÿ¶ÿ≤ ŸáŸà:'; victorName.textContent = winner.name; victoryOverlay.style.display = 'flex'; playVictorySound(); } }

  function returnToLobby(){ if(prodTimer) clearInterval(prodTimer); if(botTimer) clearInterval(botTimer); victoryOverlay.style.display = 'none'; document.getElementById('lobby').style.display = 'flex'; buildGrid(); setupPlayers(parseInt(playerCount.value,10)||4); seedCapitals(); updateLegend(); render(); }
  if(mainMenuBtn) mainMenuBtn.addEventListener('click', returnToLobby); if(victoryToLobby) victoryToLobby.addEventListener('click', returnToLobby);

  // --------------------
  // INPUT
  // --------------------
  if(ratioSlider && ratioValue) ratioSlider.addEventListener('input', e=> ratioValue.textContent = e.target.value + '%');
  gameCanvas.addEventListener('pointerdown', e=>{ dragging = true; lastX = e.clientX; lastY = e.clientY; gameCanvas.setPointerCapture && gameCanvas.setPointerCapture(e.pointerId); needRender = true; });
  gameCanvas.addEventListener('pointerup', e=>{ dragging = false; gameCanvas.releasePointerCapture && gameCanvas.releasePointerCapture(e.pointerId); needRender = true; });
  gameCanvas.addEventListener('pointermove', e=>{ if(!dragging) return; cam.x += (e.clientX - lastX) / cam.scale; cam.y += (e.clientY - lastY) / cam.scale; lastX = e.clientX; lastY = e.clientY; needRender = true; });
  gameCanvas.addEventListener('click', e=>{ const pos = screenToWorld(e.clientX, e.clientY); const idx = cellAt(pos.x, pos.y); if(idx == null) return; const cell = grid[idx]; // multiplayer: only allow selecting your own cells
    if(selected === null){
      if(multiplayerMode){
        if(cell.owner === localPlayerIndex) selected = idx;
        else { /* ignore selection of other players' cells */ }
      } else {
        if(cell.owner === 0) selected = idx;
      }
    } else {
      if(idx !== selected && isNeighbor(selected, idx)){
        const ratio = ratioSlider ? parseInt(ratioSlider.value,10)/100 : 0.5;
        moveTroops(selected, idx, ratio, true);
      }
      selected = null;
    }
    needRender = true;
  });

  // --------------------
  // START
  // --------------------
  function startGame(){ try{ if(!grid || grid.length < 8) buildGrid(); const cnt = playerCount ? Math.max(2, Math.min(4, parseInt(playerCount.value,10) || 4)) : 4; setupPlayers(cnt); seedCapitals(); startProduction(prodRate ? parseInt(prodRate.value,10) : 900); if(botTimer) clearInterval(botTimer); botTimer = setInterval(botTick, 900); document.getElementById('lobby').style.display = 'none'; updateLegend(); needRender = true; }catch(err){ console.error(err); debugLog('startGame error: '+err,'#f55'); dbg.style.display='block'; dbg.textContent = String(err); } }
  window.startGame = startGame; if(startBtn) startBtn.addEventListener('click', startGame);

  // loop
  let last = performance.now(); function frame(now){ const dt = now - last; last = now; try{ updateEffectsAndAnimations(dt); if(needRender || animations.length>0 || effects.length>0){ render(); } }catch(e){ console.error(e); debugLog('frame error: '+e,'#f55'); dbg.style.display='block'; dbg.textContent = String(e); } requestAnimationFrame(frame); } requestAnimationFrame(frame);

  // initial preview
  buildGrid(); setupPlayers(4); seedCapitals(); updateLegend(); needRender = true;

});
</script>

<!-- =========================
     Firebase + Multiplayer logic (improved)
     ========================== -->
<script type="module">
  // Firebase config (from you)
  const firebaseConfig = {
    apiKey: "AIzaSyDKBOpclh-zb8pACwUvLyTTzXwyRhHijKo",
    authDomain: "terrtioral.firebaseapp.com",
    databaseURL: "https://terrtioral-default-rtdb.firebaseio.com",
    projectId: "terrtioral",
    storageBucket: "terrtioral.firebasestorage.app",
    messagingSenderId: "45249886132",
    appId: "1:45249886132:web:24ee3e122db9809d3464e1",
    measurementId: "G-G7NQ9LMTL5"
  };

  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
  import { getDatabase, ref, set, push, onValue, onChildAdded, onChildChanged, remove, update, get } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-database.js";

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);

  function debug(msg){ try{ const c = document.getElementById('inGameConsole'); if(c){ const d = document.createElement('div'); d.style.color = '#0f0'; d.textContent = msg; c.appendChild(d); c.scrollTop = c.scrollHeight; } console.log(msg);}catch(e){} }

  function genRoomId(len=6){
    const chars = "abcdefghijklmnopqrstuvwxyz0123456789";
    let s="";
    for(let i=0;i<len;i++) s+=chars[Math.floor(Math.random()*chars.length)];
    return s;
  }

  let currentRoom = null;
  let myId = null;
  let myName = null;
  let isHost = false;
  let playersRef = null;
  let actionsRef = null;

  // DOM
  const onlineBtn = document.getElementById('onlineBtn');
  const lobbyModal = document.getElementById('lobbyModal');
  const nicknameInput = document.getElementById('nicknameInput');
  const createRoomBtn = document.getElementById('createRoomBtn');
  const joinRoomBtn = document.getElementById('joinRoomBtn');
  const roomIdInput = document.getElementById('roomIdInput');
  const playersList = document.getElementById('playersList');
  const startGameBtn = document.getElementById('startGameBtn');
  const leaveBtn = document.getElementById('leaveBtn');

  function openLobby(){
    lobbyModal.style.display = 'flex';
    lobbyModal.setAttribute('aria-hidden','false');
  }
  function closeLobby(){
    lobbyModal.style.display = 'none';
    lobbyModal.setAttribute('aria-hidden','true');
  }

  if(!onlineBtn){
    console.error('onlineBtn not found');
  } else {
    onlineBtn.addEventListener('click', ()=>{
      try{ openLobby(); }catch(e){ console.error('openLobby error', e); debug('openLobby error: '+e); }
    });
  }

  createRoomBtn.addEventListener('click', async ()=>{
    myName = (nicknameInput.value || 'Guest').trim();
    if(!myName) { alert('ÿßŸÉÿ™ÿ® ÿßÿ≥ŸÖ'); return; }
    const id = genRoomId(6);
    currentRoom = id;
    myId = 'p_' + Date.now() + '_' + Math.floor(Math.random()*1000);
    isHost = true;
    const roomRef = ref(db, 'rooms/' + id);
    await set(roomRef, {
      host: myId,
      started: false,
      createdAt: Date.now()
    });
    playersRef = ref(db, 'rooms/' + id + '/players');
    const newPlayerRef = ref(db, 'rooms/' + id + '/players/' + myId);
    await set(newPlayerRef, {
      id: myId,
      name: myName,
      color: null,
      joinedAt: Date.now()
    });
    roomIdInput.value = id;
    joinListeners(id);
    updateUIRoomCreated();
    debug('room created: '+id);
  });

  joinRoomBtn.addEventListener('click', async ()=>{
    myName = (nicknameInput.value || 'Guest').trim();
    if(!myName) { alert('ÿßŸÉÿ™ÿ® ÿßÿ≥ŸÖ'); return; }
    const id = (roomIdInput.value || '').trim();
    if(!id){ alert('ÿßŸÉÿ™ÿ® ŸÖÿπÿ±ŸÅ ÿßŸÑÿ∫ÿ±ŸÅÿ©'); return; }
    const roomRef = ref(db, 'rooms/' + id);
    const snap = await get(roomRef);
    if(!snap.exists()){
      alert('ÿßŸÑÿ∫ÿ±ŸÅÿ© ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©');
      return;
    }
    currentRoom = id;
    myId = 'p_' + Date.now() + '_' + Math.floor(Math.random()*1000);
    const playersCountSnap = await get(ref(db, 'rooms/' + id + '/players'));
    const count = playersCountSnap.exists() ? Object.keys(playersCountSnap.val()).length : 0;
    if(count >= 4){ alert('ÿßŸÑÿ∫ÿ±ŸÅÿ© ŸÖŸÖÿ™ŸÑÿ¶ÿ©'); return; }
    const newPlayerRef = ref(db, 'rooms/' + id + '/players/' + myId);
    await set(newPlayerRef, {
      id: myId,
      name: myName,
      color: null,
      joinedAt: Date.now()
    });
    const roomSnap = await get(roomRef);
    const roomVal = roomSnap.val();
    isHost = (roomVal && roomVal.host === myId);
    joinListeners(id);
    updateUIRoomJoined();
    debug('joined room: '+id);
  });

  function updateUIRoomCreated(){
    leaveBtn.style.display = 'block';
    startGameBtn.style.display = 'block';
    createRoomBtn.disabled = true;
    joinRoomBtn.disabled = true;
  }
  function updateUIRoomJoined(){
    leaveBtn.style.display = 'block';
    startGameBtn.style.display = 'block';
    createRoomBtn.disabled = true;
    joinRoomBtn.disabled = true;
  }

  function randomColor(){
    const colors = ['#e53935','#8e24aa','#3949ab','#00897b','#f4511e','#fb8c00','#43a047','#1e88e5','#7b1fa2','#d32f2f'];
    return colors[Math.floor(Math.random()*colors.length)];
  }

  async function renderPlayers(playersObj){
    playersList.innerHTML = '';
    const arr = playersObj ? Object.values(playersObj) : [];
    // ensure unique colors: read used colors and pick unused
    const used = new Set(arr.map(p=>p.color).filter(Boolean));
    const pool = ['#e53935','#8e24aa','#3949ab','#00897b','#f4511e','#fb8c00','#43a047','#1e88e5','#7b1fa2','#d32f2f'];
    for(const p of arr){
      if(!p.color){
        // pick unused
        let c = pool.find(c=>!used.has(c));
        if(!c) c = pool[Math.floor(Math.random()*pool.length)];
        used.add(c);
        p.color = c;
        // write immediately and await to reduce race
        try{ await set(ref(db, 'rooms/' + currentRoom + '/players/' + p.id + '/color'), c); }catch(e){ console.warn('set color failed',e); debug('set color failed: '+e); }
      }
    }
    const playersArray = arr.sort((a,b)=> (a.joinedAt||0)-(b.joinedAt||0));
    for(const p of playersArray){
      const div = document.createElement('div');
      div.className='playerItem';
      const hostBadge = (p.id === roomHostId) ? '<div class="hostBadge">Host</div>' : '';
      div.innerHTML = `<div style="display:flex;gap:8px;align-items:center"><div style="width:12px;height:12px;background:${p.color};border-radius:50%"></div><div>${escapeHtml(p.name)}</div></div>` + hostBadge;
      playersList.appendChild(div);
    }
    const count = playersArray.length;
    startGameBtn.disabled = !(isHost && count>=2);
  }

  function getHostId(){
    return roomHostId;
  }

  async function joinListeners(roomId){
    playersRef = ref(db, 'rooms/' + roomId + '/players');
    onValue(playersRef, (snap)=>{
      const playersObj = snap.exists() ? snap.val() : {};
      currentRoomPlayersList = Object.values(playersObj || {}).sort((a,b)=>(a.joinedAt||0)-(b.joinedAt||0));
      assignColorsIfMissing(currentRoomPlayersList).then(arr=>{
        renderPlayers(playersObj);
      }).catch(e=>{
        console.warn('assignColorsIfMissing error',e); renderPlayers(playersObj);
      });
    });
    onValue(ref(db, 'rooms/' + roomId), (snap)=>{
      const v = snap.val();
      if(!v) return;
      roomHostId = v.host || null;
      isHost = (roomHostId === myId);
      get(ref(db, 'rooms/' + roomId + '/players')).then(psnap=>{
        renderPlayers(psnap.exists()?psnap.val():{});
      }).catch(()=>{});
      if(v.started){
        handleRemoteStart();
      }
    });
    listenActions(roomId);
    currentRoom = roomId;
  }

  async function assignColorsIfMissing(playersArr){
    const pool = ['#e53935','#8e24aa','#3949ab','#00897b','#f4511e','#fb8c00','#43a047','#1e88e5','#7b1fa2','#d32f2f'];
    const used = new Set(playersArr.filter(p=>p.color).map(p=>p.color));
    for(const p of playersArr){
      if(!p.color){
        let c = pool.find(pc=>!used.has(pc));
        if(!c) c = pool[Math.floor(Math.random()*pool.length)];
        used.add(c);
        p.color = c;
        try{ await set(ref(db, 'rooms/' + currentRoom + '/players/' + p.id + '/color'), c); }catch(e){ console.warn('failed set color',e); debug('failed set color: '+e); }
      }
    }
    return playersArr;
  }

  leaveBtn.addEventListener('click', async ()=>{
    if(!currentRoom || !myId) return;
    await remove(ref(db, 'rooms/' + currentRoom + '/players/' + myId));
    const roomPlayers = await get(ref(db, 'rooms/' + currentRoom + '/players'));
    if(roomPlayers.exists()){
      const playersObj = roomPlayers.val();
      const keys = Object.keys(playersObj);
      if(keys.length>0){
        const newHost = playersObj[keys[0]].id;
        await update(ref(db, 'rooms/' + currentRoom), { host: newHost });
      } else {
        await remove(ref(db, 'rooms/' + currentRoom));
      }
    } else {
      await remove(ref(db, 'rooms/' + currentRoom));
    }
    cleanupLocal();
    closeLobby();
  });

  startGameBtn.addEventListener('click', async ()=>{
    if(!currentRoom || !myId) return;
    const roomSnap = await get(ref(db, 'rooms/' + currentRoom));
    const roomVal = roomSnap.exists()?roomSnap.val():null;
    if(!roomVal) { alert('ÿßŸÑÿ∫ÿ±ŸÅÿ© ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ±ÿ©'); return; }
    const hostId = roomVal.host;
    if(hostId !== myId){ alert('ŸÅŸÇÿ∑ ÿßŸÑŸáŸàÿ≥ÿ™ ŸäŸÖŸÉŸÜŸá ÿ®ÿØÿ° ÿßŸÑŸÑÿπÿ®ÿ©'); return; }
    const playersSnap = await get(ref(db, 'rooms/' + currentRoom + '/players'));
    const arr = playersSnap.exists()?Object.values(playersSnap.val()):[];
    if(arr.length < 2){ alert('ÿßŸÑÿ≠ÿØ ÿßŸÑÿßÿØŸÜŸâ ŸÑÿ®ÿØÿ° ÿßŸÑŸÑÿπÿ®ÿ© ŸáŸà 2 ŸÑÿßÿπÿ®ŸäŸÜ'); return; }
    await update(ref(db, 'rooms/' + currentRoom), { started: true });
    const prepared = await assignColorsIfMissing(arr);
    await set(ref(db, 'games/' + currentRoom + '/meta'), { players: prepared, startedAt: Date.now(), host: myId });
    handleLocalStart();
  });

  function handleRemoteStart(){
    if(!currentRoom) return;
    get(ref(db, 'games/' + currentRoom + '/meta')).then(snap=>{
      const meta = snap.exists()?snap.val():null;
      if(!meta || !meta.players) {
        get(ref(db, 'rooms/' + currentRoom + '/players')).then(psnap=>{
          const arr = psnap.exists()?Object.values(psnap.val()):[];
          startMultiplayerGame(arr, false);
        });
      } else {
        startMultiplayerGame(meta.players, false);
      }
    }).catch(e=>{
      console.error('handleRemoteStart error', e);
      debug('handleRemoteStart error: '+e);
    });
    closeLobby();
  }

  function handleLocalStart(){
    if(!currentRoom) return;
    get(ref(db, 'rooms/' + currentRoom + '/players')).then(psnap=>{
      const arr = psnap.exists()?Object.values(psnap.val()):[];
      startMultiplayerGame(arr, true);
    });
    closeLobby();
  }

  async function startMultiplayerGame(arr, hostFlag){
    multiplayerMode = true;
    await assignColorsIfMissing(arr);
    const decorated = arr.map(p=>({ id:p.id, name:p.name, color:p.color }));
    const n = decorated.length;
    setupPlayers(n);
    for(let i=0;i<players.length;i++){
      players[i].dbId = decorated[i].id;
      players[i].name = decorated[i].name || players[i].name;
      players[i].color = decorated[i].color || players[i].color;
    }
    localPlayerIndex = 0;
    for(let i=0;i<players.length;i++){
      if(players[i].dbId === myId){ localPlayerIndex = i; break; }
    }
    seedCapitalsMultiplayer(decorated);
    updateLegend();
    startProduction(parseInt(prodRate.value,10) || 900);
    if(window.multiplayer && typeof window.multiplayer.sendAction === 'function') debug('multiplayer sendAction ready');
    const ev = new CustomEvent('multiplayer_start_local', { detail: { room: currentRoom, host: hostFlag }});
    window.dispatchEvent(ev);
    document.getElementById('lobby').style.display = 'none';
    debug('Multiplayer started. localIndex='+localPlayerIndex);
  }

  function cleanupLocal(){
    currentRoom = null; myId = null; myName = null; isHost = false;
    playersList.innerHTML = '';
    leaveBtn.style.display = 'none';
    startGameBtn.style.display = 'none';
    createRoomBtn.disabled = false;
    joinRoomBtn.disabled = false;
    multiplayerMode = false;
  }

  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, function(m){return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m];}); }

  async function sendAction(action){
    if(!currentRoom) return;
    const ar = ref(db, 'games/' + currentRoom + '/actions');
    const p = push(ar);
    await set(p, { from: myId, t: Date.now(), action });
  }

  function listenActions(roomId){
    actionsRef = ref(db, 'games/' + roomId + '/actions');
    onChildAdded(actionsRef, (snap)=>{
      const v = snap.val();
      if(!v) return;
      if(v.from === myId) return; // ignore own echoes
      const action = v.action;
      if(!action) return;
      if(action.type === 'move'){
        try{
          moveTroops(action.from, action.to, action.ratio || 0.5, false);
        }catch(e){ console.error('apply move action failed', e); debug('apply move action failed: '+e); }
      }
    });
  }

  // expose functions
  window.multiplayer = {
    sendAction,
    getCurrentRoom: ()=>currentRoom,
    isHost: ()=>isHost,
    getMyId: ()=>myId,
    getMyName: ()=>myName
  };

  lobbyModal.addEventListener('click', (e)=>{
    if(e.target === lobbyModal) closeLobby();
  });

  window.addEventListener('beforeunload', async ()=>{
    try{
      if(currentRoom && myId){
        await remove(ref(db, 'rooms/' + currentRoom + '/players/' + myId));
      }
    }catch(e){}
  });

  debug('Firebase multiplayer lobby loaded');
</script>

</body>
</html>
<!-- PATCHED BY CHATGPT -->
<script>
// Fix: toggle debug console with close button
document.addEventListener('DOMContentLoaded', () => {
  const dbg = document.getElementById('dbg');
  if (dbg) {
    dbg.style.maxHeight = '40vh';
    dbg.style.overflowY = 'auto';
    // Add close button
    const btn = document.createElement('button');
    btn.textContent = '√ó';
    btn.style.position = 'absolute';
    btn.style.right = '4px';
    btn.style.top = '4px';
    btn.style.background='red';
    btn.style.color='white';
    btn.style.border='none';
    btn.style.borderRadius='4px';
    btn.style.cursor='pointer';
    btn.onclick = ()=>{ dbg.style.display='none'; };
    dbg.style.position='relative';
    dbg.appendChild(btn);
  }

  // Fix online back button
  const mainMenuBtn = document.getElementById('mainMenuBtn');
  const lobbyModal = document.getElementById('lobbyModal');
  if (mainMenuBtn && lobbyModal) {
    mainMenuBtn.addEventListener('click', ()=>{
      lobbyModal.style.display='none';
    });
  }

  // Host start safeguard
  window.addEventListener('multiplayer_start_local', ()=>{
    console.log('Multiplayer start triggered');
  });
});
</script>
