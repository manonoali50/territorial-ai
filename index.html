<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Territorial ‚Äî WebSocket Multiplayer</title>
<style>
html,body{margin:0;padding:0;overflow:hidden;background:#0d1117;font-family:Tahoma,Arial,sans-serif}
canvas{display:block;touch-action:none}
#lobby{position:fixed;inset:0;z-index:2000;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,#0d1117,#111827,#1a2333)}
.card{background:rgba(6,10,18,0.9);backdrop-filter:blur(8px);padding:24px;border-radius:14px;width:360px;box-shadow:0 12px 40px rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.04);color:#e6eef8}
.card h1{margin:0 0 12px;font-size:20px;text-align:center}
label{display:block;color:#aeb9c8;margin-top:10px}
select,input[type=range]{width:100%;margin:8px 0;padding:10px;border-radius:10px;border:none;background:#101521;color:#fff}
button{padding:12px;border-radius:10px;border:none;cursor:pointer;font-weight:700}
.green{background:#16a34a;color:white}
#ratioBar{position:fixed;left:50%;transform:translateX(-50%);bottom:12px;background:rgba(255,255,255,0.92);padding:10px 12px;border-radius:14px;display:flex;align-items:center;gap:12px;z-index:1800}
#ratioBar input{width:160px}
#legend{position:fixed;left:12px;top:12px;z-index:1800;color:white;display:flex;flex-direction:column;gap:6px}
.legend-item{display:flex;align-items:center;gap:8px;background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:8px}
#dbg{position:fixed;right:8px;bottom:8px;z-index:2200;background:rgba(0,0,0,0.7);color:#fff;padding:8px;border-radius:8px;font-size:12px;display:none;max-width:40vw}
#mainMenuBtn{position:fixed;right:12px;top:12px;z-index:2100;background:#2563eb;color:white;padding:8px 12px;border-radius:10px;box-shadow:0 8px 20px rgba(0,0,0,0.3);cursor:pointer}
#victoryOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:3000}
#victoryCard{background:linear-gradient(180deg,rgba(255,255,255,0.06),rgba(255,255,255,0.03));backdrop-filter:blur(8px);padding:28px;border-radius:16px;text-align:center;color:white;box-shadow:0 30px 80px rgba(0,0,0,0.6)}
.consoleBtn{position:fixed;top:12px;left:50%;transform:translateX(360px);z-index:4000;background:#1f2937;color:#fff;padding:8px 12px;border-radius:8px;cursor:pointer}
#consoleBox{position:fixed;top:12px;left:50%;transform:translateX(-50%);width:70vw;max-width:640px;height:40vh;background:#000;color:#0f0;z-index:4001;border-radius:8px;padding:12px;display:none;box-shadow:0 10px 30px rgba(0,0,0,0.6)}
#consoleBox .header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
#consoleBox .close{background:#111;color:#fff;border-radius:6px;padding:6px 8px;cursor:pointer}
#lobbyModal{display:none;position:fixed;z-index:9999;left:0;top:0;right:0;bottom:0;background:rgba(0,0,0,0.6);align-items:center;justify-content:center;padding:20px}
#lobbyBox{background:#111;color:#fff;border-radius:12px;padding:18px;max-width:420px;width:100%;box-shadow:0 10px 30px rgba(0,0,0,0.7)}
.playerItem{padding:6px;border-bottom:1px solid rgba(255,255,255,0.03);display:flex;justify-content:space-between;align-items:center;}
.hostBadge{background:#ffd633;color:#000;padding:4px 8px;border-radius:6px;font-weight:700;font-size:12px}
</style>
</head>
<body>

<canvas id="game"></canvas>
<canvas id="lineLayer" style="position:fixed;inset:0;pointer-events:none;z-index:1700"></canvas>

<div id="ratioBar" aria-hidden="false">
  <span style="font-weight:700">ÿßŸÑŸÇŸàÿßÿ™:</span>
  <input id="ratioSlider" type="range" min="10" max="100" value="50">
  <span id="ratioValue">50%</span>
</div>

<div id="mainMenuBtn" role="button">‚üµ ÿ±ÿ¨Ÿàÿπ</div>

<div id="lobby" role="dialog" aria-label="Lobby">
  <div class="card">
    <h1>ŸÑŸàÿ®Ÿä ÿßŸÑŸÑÿπÿ®ÿ©</h1>

    <label>ÿπÿØÿØ ÿßŸÑŸÑÿßÿπÿ®ŸäŸÜ</label>
    <select id="playerCount">
      <option value="2">2</option>
      <option value="3">3</option>
      <option value="4" selected>4</option>
    </select>

    <label>ŸÖÿπÿØŸÑ ÿßŸÑÿ•ŸÜÿ™ÿßÿ¨ (ŸÖŸÑŸÑŸä ÿ´ÿßŸÜŸäÿ©)</label>
    <input id="prodRate" type="range" min="300" max="2000" value="900">

    <div style="margin-top:12px">
      <button id="startBtn" class="green" style="width:100%">ÿßÿ®ÿØÿ£ (ÿ£ŸàŸÅŸÑÿßŸäŸÜ)</button>

    <button id="onlineBtn" style="display:block;margin:16px auto;padding:14px 20px;background:#0b8f3b;color:#fff;border-radius:12px;font-size:18px;border:none;cursor:pointer;max-width:360px;width:90%;text-align:center;">
      ÿßŸÑŸÑÿπÿ® ÿ£ŸàŸÜŸÑÿßŸäŸÜ
    </button>

    <div id="lobbyModal" role="dialog" aria-hidden="true">
      <div id="lobbyBox">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <h2 style="margin:0">ŸÑŸàÿ®Ÿä ÿßŸÑÿ£ŸàŸÜŸÑÿßŸäŸÜ</h2>
          <div style="display:flex;gap:8px">
            <button id="backToLobby" style="background:#374151;color:#fff;padding:8px;border-radius:8px;border:none;cursor:pointer">ÿ±ÿ¨Ÿàÿπ</button>
            <button id="closeLobbyModal" style="background:#111;color:#fff;padding:8px;border-radius:8px;border:none;cursor:pointer">ÿ•ÿ∫ŸÑÿßŸÇ</button>
          </div>
        </div>
        <input id="nicknameInput" placeholder="ÿßŸÑÿßÿ≥ŸÖ (ŸÖÿ´ÿßŸÑ: Ali)" style="width:100%;padding:8px;margin-top:8px;border-radius:8px;border:1px solid #333;background:#0f0f10;color:#fff" />
        <div style="display:flex;gap:8px;margin-top:8px;">
          <button id="createRoomBtn" style="flex:1;background:#2e7d32;color:#fff;border:none;padding:10px;border-radius:8px;cursor:pointer">ÿßŸÜÿ¥ÿßÿ° ÿ∫ÿ±ŸÅÿ©</button>
          <button id="joinRoomBtn" style="flex:1;background:#455a64;color:#fff;border:none;padding:10px;border-radius:8px;cursor:pointer">ÿßŸÜÿ∂ŸÖ ŸÑÿ∫ÿ±ŸÅÿ©</button>
        </div>
        <input id="roomIdInput" placeholder="ŸÖÿπÿ±ŸÅ ÿßŸÑÿ∫ÿ±ŸÅÿ© (Room ID)" style="width:100%;padding:8px;margin-top:8px;border-radius:8px;border:1px solid #333;background:#0f0f10;color:#fff" />
        <div id="playersList" aria-live="polite" style="max-height:160px;overflow:auto;margin:8px 0;padding:6px;background:#071018;border-radius:6px"></div>
        <div style="display:flex;gap:8px;margin-top:8px;">
          <button id="startGameBtn" style="flex:1;background:#1976d2;color:#fff;border:none;padding:10px;border-radius:8px;cursor:pointer" disabled>ÿ®ÿØÿ° ÿßŸÑŸÑÿπÿ®ÿ© (ŸÅŸÇÿ∑ ÿßŸÑŸáŸàÿ≥ÿ™)</button>
          <button id="leaveBtn" style="flex:1;background:#b71c1c;color:#fff;border:none;padding:10px;border-radius:8px;display:none;cursor:pointer">ÿßŸÑÿÆÿ±Ÿàÿ¨</button>
        </div>
      </div>
    </div>

    </div>
  </div>
</div>

<div id="legend" aria-hidden="true"></div>
<div id="dbg" role="status"></div>

<div id="victoryOverlay"><div id="victoryCard"><div class="crown">üëë</div><h1 id="victoryText"></h1><div id="victorName" style="font-size:20px;margin-top:6px"></div><button id="victoryToLobby" class="green">ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑŸëŸàÿ®Ÿä</button></div></div>

<button class="consoleBtn" id="consoleToggle">Console</button>
<div id="consoleBox" aria-hidden="true">
  <div class="header">
    <div>Console</div>
    <div style="display:flex;gap:8px">
      <button id="clearConsole" class="close">Clear</button>
      <button id="closeConsole" class="close">‚úï</button>
    </div>
  </div>
  <pre id="consoleOutput" style="white-space:pre-wrap;overflow:auto;height:calc(100% - 36px);"></pre>
</div>

<script>
const consoleBox = document.getElementById('consoleBox');
const consoleToggle = document.getElementById('consoleToggle');
const consoleOutput = document.getElementById('consoleOutput');
const closeConsole = document.getElementById('closeConsole');
const clearConsoleBtn = document.getElementById('clearConsole');
function logConsole(msg){ const t = (new Date()).toLocaleTimeString(); consoleOutput.textContent += t + ' ‚Äî ' + msg + "\\n"; consoleOutput.scrollTop = consoleOutput.scrollHeight; }
consoleToggle.addEventListener('click', ()=>{ consoleBox.style.display='block'; logConsole('Console opened'); });
closeConsole.addEventListener('click', ()=>{ consoleBox.style.display='none'; logConsole('Console closed'); });
clearConsoleBtn.addEventListener('click', ()=>{ consoleOutput.textContent=''; });

var grid = [];
document.addEventListener('DOMContentLoaded', ()=>{
  'use strict';
  const HEX = 34;
  const gameCanvas = document.getElementById('game');
  const lineCanvas = document.getElementById('lineLayer');
  const ratioSlider = document.getElementById('ratioSlider');
  const ratioValue = document.getElementById('ratioValue');
  const startBtn = document.getElementById('startBtn');
  const playerCount = document.getElementById('playerCount');
  const prodRate = document.getElementById('prodRate');
  const legendEl = document.getElementById('legend');
  const lobbyEl = document.getElementById('lobby');
  const lobbyModal = document.getElementById('lobbyModal');
  const playersList = document.getElementById('playersList');
  const startGameBtn = document.getElementById('startGameBtn');
  const leaveBtn = document.getElementById('leaveBtn');
  const backToLobby = document.getElementById('backToLobby');
  const closeLobbyModal = document.getElementById('closeLobbyModal');

  let W=0,H=0; function resize(){ W=gameCanvas.width=window.innerWidth; H=gameCanvas.height=window.innerHeight; lineCanvas.width=W; lineCanvas.height=H; needRender=true; }
  window.addEventListener('resize', resize); resize();
  const ctx = gameCanvas.getContext('2d');
  const lctx = lineCanvas.getContext('2d');

  var players = [];
  var cam = {x:0,y:0,scale:1};
  var selected = null;
  var animations = [];
  var effects = [];
  var prodTimer=null, botTimer=null;
  var dragging=false,lastX=0,lastY=0;
  var multiplayerMode=false, localPlayerIndex=0, currentRoom=null, myId=null, myName=null, isHost=false;
  var ws = null;

  function buildGrid(){
    grid.length=0;
    const cols = Math.max(8, Math.floor(W / (HEXR()*1.6)));
    const rows = Math.max(6, Math.floor(H / (HEXR()*1.25)));
    const startX = -cols * HEX * 0.85;
    const startY = -rows * HEX * 0.95;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const x = startX + c * HEX * 1.7 + (r%2?HEX*0.85:0);
        const y = startY + r * HEX * 1.45;
        grid.push({x,y,owner:null,troops:0,neighbors:[]});
      }
    }
    for(let i=0;i<grid.length;i++){
      const a=grid[i];
      for(let j=0;j<grid.length;j++){
        if(i===j) continue;
        const b=grid[j];
        if(Math.hypot(a.x-b.x,a.y-b.y)<HEX*1.75) a.neighbors.push(j);
      }
    }
    needRender=true;
  }
  function HEXR(){ return HEX; }
  function worldToScreen(x,y){ return {x:(x+cam.x)*cam.scale+W/2, y:(y+cam.y)*cam.scale+H/2}; }
  function drawHex(cx,cy,r){ ctx.beginPath(); for(let i=0;i<6;i++){ const a=Math.PI/3*i + Math.PI/6; const x=cx+Math.cos(a)*r; const y=cy+Math.sin(a)*r; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.closePath(); }
  function cellAt(wx,wy){ if(!grid||grid.length===0) return null; let best=null, bd=HEX*1.05; for(let i=0;i<grid.length;i++){ const d=Math.hypot(grid[i].x-wx, grid[i].y-wy); if(d<bd){ bd=d; best=i; } } return best; }
  function isNeighbor(a,b){ if(!grid||!grid[a]||!grid[b]) return false; return Math.hypot(grid[a].x-grid[b].x,grid[a].y-grid[b].y) < HEX * 1.8; }

  function setupPlayers(n){
    players=[]; for(let i=0;i<n;i++){ const defaultColors=['#3399ff','#ff5555','#ffe047','#8a60ff','#00c48c']; players.push({id:i,color:defaultColors[i%defaultColors.length],name:'P'+(i+1),capital:null,alive:true,dbId:null}); }
    updateLegend();
    needRender=true;
  }
  function updateLegend(){ if(!legendEl) return; legendEl.innerHTML=''; for(const p of players){ const div=document.createElement('div'); div.className='legend-item'; div.innerHTML=`<div style="width:14px;height:10px;background:${p.color};border-radius:4px"></div><div style="font-size:13px">${p.name}</div>`; legendEl.appendChild(div);} }

  function seedCapitals(){ if(!grid||grid.length===0) buildGrid(); grid.forEach(c=>{c.owner=null;c.troops=0}); const xs=grid.map(c=>c.x), ys=grid.map(c=>c.y); const cxMin=Math.min(...xs), cxMax=Math.max(...xs); const cyMin=Math.min(...ys), cyMax=Math.max(...ys); const corners=[[cxMin,cyMin],[cxMax,cyMin],[cxMin,cyMax],[cxMax,cyMax]]; const n=players.length; for(let p=0;p<n;p++){ const pt=corners[p%corners.length]; let bestIdx=0,bestD=Infinity; for(let i=0;i<grid.length;i++){ const d=Math.hypot(grid[i].x-pt[0],grid[i].y-pt[1]); if(d<bestD){bestD=d;bestIdx=i;} } grid[bestIdx].owner = players[p].id; grid[bestIdx].troops = 40; players[p].capital = bestIdx; } for(let i=0;i<grid.length;i++){ if(grid[i].owner==null && Math.random()<0.03){ grid[i].owner = Math.floor(Math.random()*players.length); grid[i].troops = 3 + Math.floor(Math.random()*4); } } needRender=true; }

  function seedCapitalsMultiplayer(dbPlayersArr){
    if(!grid||grid.length===0) buildGrid();
    grid.forEach(c=>{c.owner=null;c.troops=0});
    const xs=grid.map(c=>c.x), ys=grid.map(c=>c.y);
    const cxMin=Math.min(...xs), cxMax=Math.max(...xs);
    const cyMin=Math.min(...ys), cyMax=Math.max(...ys);
    const corners=[[cxMin,cyMin],[cxMax,cyMin],[cxMin,cyMax],[cxMax,cyMax]];
    const n=dbPlayersArr.length;
    for(let p=0;p<n;p++){
      const pt=corners[p%corners.length]; let bestIdx=0,bestD=Infinity;
      for(let i=0;i<grid.length;i++){ const d=Math.hypot(grid[i].x-pt[0],grid[i].y-pt[1]); if(d<bestD){bestD=d;bestIdx=i;} }
      grid[bestIdx].owner = p;
      grid[bestIdx].troops = 40;
      players[p].capital = bestIdx;
      players[p].dbId = dbPlayersArr[p].id;
      players[p].name = dbPlayersArr[p].name || players[p].name;
      players[p].color = dbPlayersArr[p].color || players[p].color;
    }
    needRender=true;
  }

  function startProduction(ms){ if(prodTimer) clearInterval(prodTimer); prodTimer = setInterval(()=>{ if(grid && grid.length) grid.forEach(c=>{ if(c.owner != null) c.troops++; }); }, Math.max(50, parseInt(ms,10) || 900)); }

  function animateMove(fromIdx,toIdx,color){ if(!grid||!grid[fromIdx]||!grid[toIdx]) return; animations.push({fromIdx,toIdx,color,t:0}); needRender=true; }
  function updateAnimations(delta){ lctx.clearRect(0,0,W,H); if(!grid||grid.length===0) return; const remaining=[]; for(const a of animations){ a.t += delta*0.004; if(a.t>=1) continue; const A=worldToScreen(grid[a.fromIdx].x,grid[a.fromIdx].y); const B=worldToScreen(grid[a.toIdx].x,grid[a.toIdx].y); const x=A.x + (B.x-A.x)*a.t; const y=A.y + (B.y-A.y)*a.t; lctx.beginPath(); lctx.fillStyle=a.color; lctx.arc(x,y,6*Math.max(0.6,cam.scale),0,Math.PI*2); lctx.fill(); remaining.push(a);} animations=remaining; if(animations.length>0) needRender=true; }

  function moveTroopsInternal(fromIdx,toIdx,ratio){
    if(!grid||!grid[fromIdx]||!grid[toIdx]) return;
    const f=grid[fromIdx], t=grid[toIdx];
    const send=Math.floor(f.troops * ratio);
    if(send<=0) return;
    f.troops = Math.max(0, f.troops - send);
    animateMove(fromIdx,toIdx, players[f.owner] ? players[f.owner].color : '#fff');
    if(t.owner === f.owner){ t.troops += send; }
    else {
      if(send > t.troops){
        const defeatedOwner = t.owner;
        t.owner = f.owner;
        t.troops = send - t.troops;
        if(defeatedOwner != null && players[defeatedOwner] && players[defeatedOwner].capital === toIdx){
          if(players[defeatedOwner]) players[defeatedOwner].alive = false;
          for(const c of grid){ if(c.owner === defeatedOwner){ c.owner = null; c.troops = 0; } }
          checkVictory();
        }
      } else {
        t.troops = Math.max(0, t.troops - send);
      }
    }
    needRender=true;
  }

  function moveTroops(fromIdx,toIdx,ratio,broadcast=true){
    moveTroopsInternal(fromIdx,toIdx,ratio);
    if(multiplayerMode && broadcast && ws && ws.readyState === 1){
      const action = {type:'move', from:fromIdx, to:toIdx, ratio:ratio};
      ws.send(JSON.stringify({type:'action', room:currentRoom, payload:action}));
      logConsole('sent action move');
    }
  }

  function botTick(){ if(multiplayerMode) return; if(!grid||grid.length===0) return; for(let p=1;p<players.length;p++){ const bot=players[p]; if(!bot||!bot.alive) continue; const capIdx=bot.capital; if(typeof capIdx==='number'&&capIdx!=null){ const cap=grid[capIdx]; if(cap){ const defendRadius=HEX*3.2; let threat=null,threatDist=Infinity; for(let i=0;i<grid.length;i++){ const cell=grid[i]; if(cell.owner!=null && cell.owner!==p){ const d=Math.hypot(cell.x-cap.x,cell.y-cap.y); if(d<defendRadius && d<threatDist){ threatDist=d; threat=i; } } } if(threat!=null){ const friendlyCells = grid.map((c,idx)=> c.owner===p && c.troops>6 ? idx : null).filter(i=>i!==null); if(friendlyCells.length>0){ friendlyCells.sort((a,b)=> Math.hypot(grid[a].x-cap.x,grid[a].y-cap.y)-Math.hypot(grid[b].x-cap.x,grid[b].y-cap.y)); const origin=friendlyCells[0]; moveTroops(origin, threat, 0.75); continue; } } } } const ownedIdx=grid.map((c,i)=> c.owner===p?i:null).filter(i=>i!==null); if(ownedIdx.length===0) continue; const originIdx=ownedIdx[Math.floor(Math.random()*ownedIdx.length)]; const origin=grid[originIdx]; if(!origin||origin.troops<5) continue; const neighIdx=origin.neighbors.slice(); if(neighIdx.length===0) continue; let weakestIdx=neighIdx[0]; for(const ni of neighIdx) if(grid[ni].troops < grid[weakestIdx].troops) weakestIdx=ni; moveTroops(originIdx, weakestIdx, 0.5); } }

  const DEFEND_RADIUS = HEX * 3.2;
  function drawCapitalMarker(cellIdx){ if(!grid[cellIdx]) return; const c=grid[cellIdx]; const s=worldToScreen(c.x,c.y); ctx.beginPath(); ctx.lineWidth = Math.max(2,3*cam.scale); ctx.strokeStyle='rgba(255,215,0,0.95)'; ctx.arc(s.x,s.y,HEX*cam.scale+6*cam.scale,0,Math.PI*2); ctx.stroke(); ctx.fillStyle='rgba(255,215,0,0.95)'; ctx.font=(18*Math.max(0.7,cam.scale))+'px Tahoma'; ctx.textAlign='center'; ctx.fillText('‚òÖ', s.x, s.y-(HEX*cam.scale+4*cam.scale)); }

  var needRender=true;
  function render(){
    if(!ctx) return; if(!needRender && animations.length===0 && effects.length===0) return;
    ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,W,H); ctx.fillStyle='#0d1117'; ctx.fillRect(0,0,W,H);
    if(!grid||grid.length===0) return;
    for(let i=0;i<grid.length;i++){
      const c=grid[i];
      const s=worldToScreen(c.x,c.y);
      drawHex(s.x,s.y,HEX*cam.scale);
      ctx.fillStyle = c.owner == null ? '#ffffff' : players[c.owner] ? players[c.owner].color : '#fff';
      ctx.fill();
      if(i===selected){ ctx.strokeStyle='#00ff00'; ctx.lineWidth=3; ctx.stroke(); }
      ctx.fillStyle='#000'; ctx.textAlign='center'; ctx.font=(14*Math.max(0.7,cam.scale))+'px Tahoma';
      ctx.fillText(c.troops, s.x, s.y + (5 * cam.scale));
    }
    for(const p of players){ if(p && p.capital!=null && p.alive){ drawCapitalMarker(p.capital); } }
    const now = performance.now();
    for(const p of players){ if(!p||p.capital==null||!p.alive) continue; const capIdx=p.capital; const cap=grid[capIdx]; if(!cap) continue; let danger=false; for(let i=0;i<grid.length;i++){ const cell = grid[i]; if(cell.owner != null && cell.owner !== p.id){ const d=Math.hypot(cell.x-cap.x,cell.y-cap.y); if(d < DEFEND_RADIUS){ danger=true; break; } } } if(danger){ const s=worldToScreen(cap.x,cap.y); const blink = 0.5 + 0.5 * Math.sin(now * 0.015); ctx.save(); ctx.translate(s.x, s.y - (HEX * cam.scale + 18 * cam.scale)); ctx.scale(cam.scale, cam.scale); ctx.beginPath(); ctx.moveTo(0,-8); ctx.lineTo(7,8); ctx.lineTo(-7,8); ctx.closePath(); ctx.fillStyle='rgba(255,80,80,'+blink+')'; ctx.fill(); ctx.restore(); } }
    needRender=false;
  }

  function updateEffectsAndAnimations(dt){ updateAnimations(dt); }

  ratioSlider.addEventListener('input', e=> ratioValue.textContent = e.target.value + '%');
  gameCanvas.addEventListener('pointerdown', e=>{ dragging=true; lastX=e.clientX; lastY=e.clientY; gameCanvas.setPointerCapture && gameCanvas.setPointerCapture(e.pointerId); needRender=true; });
  gameCanvas.addEventListener('pointerup', e=>{ dragging=false; gameCanvas.releasePointerCapture && gameCanvas.releasePointerRelease && gameCanvas.releasePointerCapture(e.pointerId); needRender=true; });
  gameCanvas.addEventListener('pointermove', e=>{ if(!dragging) return; cam.x += (e.clientX - lastX)/cam.scale; cam.y += (e.clientY - lastY)/cam.scale; lastX=e.clientX; lastY=e.clientY; needRender=true; });
  gameCanvas.addEventListener('click', e=>{ const pos=screenToWorld(e.clientX,e.clientY); const idx=cellAt(pos.x,pos.y); if(idx==null) return; const cell=grid[idx]; if(selected===null){ if(multiplayerMode){ if(cell.owner === localPlayerIndex) selected = idx; } else { if(cell.owner === 0) selected = idx; } } else { if(idx !== selected && isNeighbor(selected, idx)){ const ratio = ratioSlider ? parseInt(ratioSlider.value,10)/100 : 0.5; moveTroops(selected, idx, ratio, true); } selected = null; } needRender=true; });

  const SERVER_URL = 'ws://localhost:3000'; // change if needed

  function connectWS(){
    try{
      if(ws && (ws.readyState === 1 || ws.readyState === 0)) return;
      ws = new WebSocket(SERVER_URL);
      ws.addEventListener('open', ()=>{ logConsole('WS connected'); });
      ws.addEventListener('message', (ev)=>{ try{ const msg = JSON.parse(ev.data); handleServerMessage(msg); }catch(e){ logConsole('ws msg parse err '+e); } });
      ws.addEventListener('close', ()=>{ logConsole('WS closed'); setTimeout(connectWS,3000); });
      ws.addEventListener('error', (e)=>{ logConsole('WS error'); });
    }catch(e){ logConsole('WS connect exception '+e); setTimeout(connectWS,3000); }
  }

  function handleServerMessage(msg){
    if(!msg || !msg.type) return;
    if(msg.type === 'room_state'){
      renderPlayersList(msg.players || []);
    } else if(msg.type === 'joined'){
      currentRoom = msg.room;
      myId = msg.id;
      isHost = msg.isHost;
      logConsole('joined room: '+currentRoom + ' as '+myId + (isHost?' (host)':''));
      if(isHost) startGameBtn.disabled = false;
    } else if(msg.type === 'player_list'){
      renderPlayersList(msg.players || []);
    } else if(msg.type === 'start'){
      logConsole('received start');
      startMultiplayerGame(msg.players || [], false);
    } else if(msg.type === 'action'){
      const action = msg.payload;
      if(action && action.type === 'move'){
        moveTroops(action.from, action.to, action.ratio || 0.5, false);
      }
    } else if(msg.type === 'error'){
      logConsole('server error: '+(msg.message||''));
      alert('Server: '+(msg.message||''));
    }
  }

  function openLobbyModal(){ lobbyModal.style.display='flex'; lobbyModal.setAttribute('aria-hidden','false'); }
  function closeLobbyModalFunc(){ lobbyModal.style.display='none'; lobbyModal.setAttribute('aria-hidden','true'); }

  document.getElementById('createRoomBtn').addEventListener('click', ()=>{ myName = (document.getElementById('nicknameInput').value||'Guest').trim(); if(!myName) { alert('ÿßŸÉÿ™ÿ® ÿßÿ≥ŸÖ'); return; } connectWS(); ws.addEventListener('open', ()=>{ ws.send(JSON.stringify({type:'create_room', name:myName})); }); if(ws && ws.readyState===1){ ws.send(JSON.stringify({type:'create_room', name:myName})); } openLobbyModal(); });
  document.getElementById('joinRoomBtn').addEventListener('click', ()=>{ myName = (document.getElementById('nicknameInput').value||'Guest').trim(); if(!myName) { alert('ÿßŸÉÿ™ÿ® ÿßÿ≥ŸÖ'); return; } const id = (document.getElementById('roomIdInput').value||'').trim(); if(!id){ alert('ÿßŸÉÿ™ÿ® ŸÖÿπÿ±ŸÅ ÿßŸÑÿ∫ÿ±ŸÅÿ©'); return; } connectWS(); ws.addEventListener('open', ()=>{ ws.send(JSON.stringify({type:'join_room', room:id, name:myName})); }); if(ws && ws.readyState===1){ ws.send(JSON.stringify({type:'join_room', room:id, name:myName})); } openLobbyModal(); });
  document.getElementById('startGameBtn').addEventListener('click', async ()=>{ if(!currentRoom || !myId) return; if(!isHost){ alert('ŸÅŸÇÿ∑ ÿßŸÑŸáŸàÿ≥ÿ™ ŸäŸÖŸÉŸÜŸá ÿ®ÿØÿ° ÿßŸÑŸÑÿπÿ®ÿ©'); return; } if(ws && ws.readyState===1){ ws.send(JSON.stringify({type:'start_room', room:currentRoom})); } });

  backToLobby.addEventListener('click', ()=>{ closeLobbyModalFunc(); document.getElementById('lobby').style.display='flex'; });
  closeLobbyModal.addEventListener('click', ()=>{ closeLobbyModalFunc(); });

  function renderPlayersList(arr){
    playersList.innerHTML='';
    const playersArray = arr.slice();
    for(const p of playersArray){
      const div = document.createElement('div');
      div.className='playerItem';
      const hostBadge = (p.isHost) ? '<div class="hostBadge">Host</div>':'';
      div.innerHTML = `<div style="display:flex;gap:8px;align-items:center"><div style="width:12px;height:12px;background:${p.color};border-radius:50%"></div><div>${escapeHtml(p.name)}</div></div>` + hostBadge;
      playersList.appendChild(div);
    }
    startGameBtn.disabled = !(isHost && playersArray.length>=2);
  }

  function startMultiplayerGame(arr, hostFlag){
    multiplayerMode = true;
    const decorated = arr.map((p,i)=>({id:p.id,name:p.name,color:p.color||randomColor(),isHost:p.isHost}));
    const n = decorated.length;
    setupPlayers(n);
    for(let i=0;i<n;i++){
      players[i].dbId = decorated[i].id;
      players[i].name = decorated[i].name || ('P'+(i+1));
      players[i].color = decorated[i].color;
    }
    localPlayerIndex = 0;
    for(let i=0;i<players.length;i++){ if(players[i].dbId === myId){ localPlayerIndex = i; break; } }
    seedCapitalsMultiplayer(decorated);
    updateLegend();
    startProduction(prodRate?parseInt(prodRate.value,10):900);
    if(botTimer){ clearInterval(botTimer); botTimer=null; }
    document.getElementById('lobby').style.display='none';
    logConsole('Multiplayer started locally. localPlayerIndex='+localPlayerIndex);
  }

  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, function(m){return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m];}); }
  function randomColor(){ const colors=['#e53935','#e91e63','#3949ab','#00897b','#f4511e','#fb8c00','#43a047','#1e88e5','#7b1fa2','#d32f2f']; return colors[Math.floor(Math.random()*colors.length)]; }
  function screenToWorld(sx,sy){ return { x:(sx - W/2) / cam.scale - cam.x, y:(sy - H/2) / cam.scale - cam.y }; }

  let last = performance.now();
  function frame(now){ const dt = now - last; last = now; try{ updateEffectsAndAnimations(dt); if(needRender || animations.length>0 || effects.length>0) render(); }catch(e){ logConsole('render error: '+e); } requestAnimationFrame(frame); } requestAnimationFrame(frame);

  buildGrid(); setupPlayers(4); seedCapitals(); updateLegend(); needRender=true;

});
</script>
</body>
</html>
